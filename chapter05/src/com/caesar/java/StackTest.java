package com.caesar.java;

/**
 * 虚拟机栈
 * 优点：跨平台，指令集小，编译器容易实现。
 * 缺点：性能下降，实现同样的功能需要更多的指令。
 *
 * <p>
 *     栈是运行时的单位，堆是存储的单位
 * <p>
 * 栈（stack）是解决程序的运行问题，即程序如何执行，或者说如何处理数据。
 * 堆(heap)是解决数据存储的问题，即数据怎么放，放在那里。
 * <p>
 *
 * <p>
 * java虚拟机栈是什么？
 *      java虚拟机栈（JVM Stack），每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（stack frame），对应这一次次次的java方法调用
 *      是线程私有的
 * <p>
 *
 * 生命周期
 *      生命周期和线程一致。
 * 作用：主管java程序的运行，它保存方法的局部变量（8中基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。
 * 局部变量 VS 成员变量（或属性）
 * 基本数据变量 VS 引用类型变量（类、数组、接口）
 *
 * 栈的特点（优点）
 * 栈是一种快速的有效的分配存储方式，访问速度(只对栈顶帧操作所以快)仅次于程序计数器。
 * jvm直接对java栈的操作只有两个：
 *      1.每个方法执行，伴随这进栈（入栈、压栈）
 *      2.执行结束后的出栈操作
 * 对于栈来说不存在垃圾回收问题： GC：只需要对栈顶数据操作，不需要对栈帧进行回收
 * 存在OOM（内存溢出）：栈满了
 *
 * Java虚拟机规范允许java栈的大小是动态的或者固定不变的
 * 固定的java虚拟机栈，在每一个线程创建时候独立选定，线程请求分配的栈容量超过java虚拟机允许的最大容量，java虚拟机会抛出一个StackOverflowError异常。
 * 动态扩展java虚拟机栈，线程无法申请到足够的内存或者创建新线程时没有足够的内存去创建对应的虚拟机栈，java虚拟机会抛出一个OutOfMemoryError异常。
 *
 * 栈中存储什么？
 * 每个线程都有自己的栈，栈中的数据都是以栈帧（stack frame）的格式存在的。
 * 在这个线程上正在执行的每个方法都各自对应一个栈帧
 * 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。
 *
 * 栈的运行原理
 * 1.不同线程中所包含的栈帧是不允许存在相互引用的，即不可能再一个栈帧中引用另外一个线程的栈帧（每个线程都有独立的pc寄存器和栈帧）
 * 2.如果当前方法调用其他的方法，方法返回之时，当前栈帧会传回此方法的执行结果给前一个栈帧，使得前一个栈帧重新成为当前栈帧。
 * 3.java方法有两种返回函数的方式，不管哪种方式都会导致栈帧被弹出。
 *   a.正常函数返回，使用return指令
 *   b.抛出异
 *
 * 栈帧的内部结构
 * 每个栈帧中存储着：
 * 1.局部变量表（Local Variables）
 * 2.操作数栈（Operand Stack）(或者表达式栈)
 * 3.动态链接（Dynamic Linking）(或执行运行时常量池的方法引用)
 * 4.方法返回地址（return Address）（或方法正常退出或者异常退出的定义）
 * 5.一些附加信息
 * ...........
 *
 * 局部变量表
 * 局部变量表也被称之为局部变量数组或者本地变量表
 *
 * 定义：一个数字数组，主要用于存储池方法参数和定义在方法体内的局部变量（8种基本数据类型，对象引用，以及返回地址类型）
 * 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。
 *
 * 局部变量所需要的容量是在编译期确定下载的，并保存在方法code属性的maximun local variables数据项中，在方法运行期间是不会改变局部变量表的大小的。
 * 补充说明：
 * 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或者间接引用的对象都不会被回收。
 *
 * 动态链接（指向运行时常量池的方法引用）
 * 常量池的作用：为了提供一些符号和常量，以便于指令的识别。
 */
public class StackTest {

    public static void main(String[] args) {
        StackTest stackTest = new StackTest();
        stackTest.methodA();
    }

    public void methodA() {
        int a = 10;
        int b = 20;
        methodB();
    }

    private void methodB() {
        int i = 30;
        int j = 40;
    }
}
